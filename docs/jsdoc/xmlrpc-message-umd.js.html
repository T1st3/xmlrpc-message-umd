<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: xmlrpc-message-umd.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: xmlrpc-message-umd.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*!
* xmlrpc-message-umd
*
* @link https://github.com/T1st3/xmlrpc-message-umd
* @author T1st3
* @version 0.8.1
* @license https://github.com/T1st3/xmlrpc-message-umd/blob/master/LICENSE
*
*
* This AMD module is based on an XMLRPC message formatter written by Scott Andrew LePera
*
* Original work:
* Copyright 2001 Scott Andrew LePera
* scott@scottandrew.com
* http://www.scottandrew.com/xml-rpc
*
* Original License:
* You are granted the right to use and/or redistribute this
* code only if this license and the copyright notice are included
* and you accept that no warranty of any kind is made or implied
* by the author.
*
*/

/* global define */

'use strict';

(function (root, factory) {
  // Test for AMD modules
  if (typeof define === 'function' &amp;&amp; define.amd) {
    // AMD
    define([
      'btoa'
    ], factory);
  // Test for Node.js
  } else if (typeof exports === 'object') {
    // Node
    module.exports = factory(require('btoa-umd'));
  // Browser globals
  } else {
    // Browser globals
    root.XMLRPCMessage = factory(root.Btoa);
  }
}(this, function (Btoa) {
  /**
  * An XMLRPC message builder, AMD style
  * @module XMLRPCMessage
  * @namespace XMLRPCMessage
  */

  /**
  * @constructor
  * @since 0.1.0
  */
  var XMLRPCMessage = function (method) {
    // set method if supplied
    if (method) {
      this.setMethod(method);
    }
    this.params = [];
    return this;
  };

  /**
  * set method
  * @method setMethod
  * @memberof XMLRPCMessage
  * @param {string} methodName
  * @since 0.1.0
  */
  XMLRPCMessage.prototype.setMethod = function (methodName) {
    // Check methodName
    if (!methodName) {
      // keep chainability
      return this;
    }
    this.method = methodName;
    // keep chainability
    return this;
  };

  /**
  * add parameter
  * @method addParameter
  * @memberof XMLRPCMessage
  * @param {*} data
  * @since 0.1.0
  */
  XMLRPCMessage.prototype.addParameter = function (data) {
    // Check data
    if (arguments.length === 0) {
      // keep chainability
      return this;
    }
    this.params[this.params.length] = data;
    // keep chainability
    return this;
  };

  /**
  * render xml message
  * @method xml
  * @memberof XMLRPCMessage
  * @since 0.1.0
  */
  XMLRPCMessage.prototype.xml = function () {
    var xml = '',
    i = 0,
    data = null;
    xml += '&lt;?xml version=\'1.0\'?>\n';
    xml += '&lt;methodCall>\n';
    xml += '&lt;methodName>' + this.method + '&lt;/methodName>\n';
    xml += '&lt;params>\n';
    for (i = 0; i &lt; this.params.length; i++) {
      data = this.params[i];
      xml += '&lt;param>\n';
      xml += '&lt;value>';
      xml += XMLRPCMessage.getParamXML(data, XMLRPCMessage.dataTypeOf(data));
      xml += '&lt;/value>\n';
      xml += '&lt;/param>\n';
    }
    xml += '&lt;/params>\n';
    xml += '&lt;/methodCall>';

    return xml;
  };

  /**
  * get type of a var
  * @method dataTypeOf
  * @memberof XMLRPCMessage
  * @param {*} o
  * @param {string} forceType
  * @since 0.1.0
  */
  XMLRPCMessage.dataTypeOf = function (o, forceType) {
    if (forceType) {
      return forceType;
    }
    // false if no o
    if (!o &amp;&amp; o !== false) {
      return false;
    }
    var type = typeof(o),
    con = null;
    type = type.toLowerCase();
    switch (type) {
      case 'number':
        if (Math.round(o) === o) {
          type = 'int';
        } else {
          type = 'double';
        }
        break;
      case 'object':
        con = o.constructor;
        if (con === Btoa) {
          type = 'base64';
        } else {
          if (con === Date) {
          type = 'date';
          } else {
            if (con === Array) {
              type = 'array';
            } else {
              type = 'struct';
            }
          }
        }
        break;
    }
    return type;
  };

  /**
  * XMLize a string or a number
  * @method doValueXML
  * @memberof XMLRPCMessage
  * @param {*} data
  * @param {string} type
  * @since 0.1.0
  */
  XMLRPCMessage.doValueXML = function (data, type) {
    // empty if no data
    if (!data) {
      return '';
    }
    var xml = '&lt;' + type + '>' + data + '&lt;/' + type + '>';
    return xml;
  };

  /**
  * XMLize a boolean
  * @method doBooleanXML
  * @memberof XMLRPCMessage
  * @param {boolean} data
  * @since 0.1.0
  */
  XMLRPCMessage.doBooleanXML = function (data) {
    // empty if no data
    if (!data &amp;&amp; data !== false) {
      return '';
    }
    var value = (data === true) ? 1 : 0;
    return '&lt;boolean>' + value + '&lt;/boolean>';
  };

  /**
  * XMLize a date
  * @method doDateXML
  * @memberof XMLRPCMessage
  * @param {Object} data
  * @since 0.1.0
  */
  XMLRPCMessage.doDateXML = function (data) {
    // empty if no data
    if (!data) {
      return '';
    }
    var xml = '&lt;dateTime.iso8601>';
    xml += XMLRPCMessage.dateToISO8601(data);
    xml += '&lt;/dateTime.iso8601>';
    return xml;
  };

  /**
  * XMLize base64 data
  * @method doBase64XML
  * @memberof XMLRPCMessage
  * @param {Object} data
  * @since 0.1.0
  */
  XMLRPCMessage.doBase64XML = function (data) {
    // empty if no data
    if (!data) {
      return '';
    }
    var xml = '&lt;base64>';
    xml += data.a;
    xml += '&lt;/base64>';
    return xml;
  };

  /**
  * XMLize an array
  * @method doArrayXML
  * @memberof XMLRPCMessage
  * @param {Orray} data
  * @since 0.1.0
  */
  XMLRPCMessage.doArrayXML = function (data) {
    // empty if no data
    if (!data) {
      return '';
    }
    var xml = '&lt;array>&lt;data>\n',
    i = 0;
    for (i = 0; i &lt; data.length; i++) {
      xml += '&lt;value>';
      xml += XMLRPCMessage.getParamXML(data[i], XMLRPCMessage.dataTypeOf(data[i]));
      xml += '&lt;/value>\n';
    }
    xml += '&lt;/data>&lt;/array>\n';
    return xml;
  };

  /**
  * Create an XML 'struct' block
  * @method doStructXML
  * @memberof XMLRPCMessage
  * @param {Object|Array} data
  * @since 0.1.0
  */
  XMLRPCMessage.doStructXML = function (data) {
    // empty if no data
    if (!data) {
      return '';
    }
    var xml = '&lt;struct>\n',
    i = 0;
    for (i in data) {
      xml += '&lt;member>\n';
      xml += '&lt;name>' + i + '&lt;/name>\n';
      xml += '&lt;value>' ;
      xml += XMLRPCMessage.getParamXML(data[i], XMLRPCMessage.dataTypeOf(data[i]));
      xml += '&lt;/value>\n';
      xml += '&lt;/member>\n';
    }
    xml += '&lt;/struct>\n';
    return xml;
  };

  /**
  * XMLize any var
  * @method getParamXML
  * @memberof XMLRPCMessage
  * @param {*} data
  * @param {string} type
  * @since 0.1.0
  */
  XMLRPCMessage.getParamXML = function (data, type) {
    if (!data &amp;&amp; data !== false) {
      return false;
    }
    if (!type) {
      type = 'string';
    }
    var xml;
    switch (type) {
      case 'base64':
        xml = XMLRPCMessage.doBase64XML(data);
        break;
      case 'date':
        xml = XMLRPCMessage.doDateXML(data);
        break;
      case 'array':
        xml = XMLRPCMessage.doArrayXML(data);
        break;
      case 'struct':
        xml = XMLRPCMessage.doStructXML(data);
        break;
      case 'boolean':
        xml = XMLRPCMessage.doBooleanXML(data);
        break;
      default:
        xml = XMLRPCMessage.doValueXML(data, type);
        break;
    }
    return xml;
  };

  /**
  * Date to Iso8601
  * @method dateToISO8601
  * @memberof XMLRPCMessage
  * @param {Object} date
  * @since 0.1.0
  */
  XMLRPCMessage.dateToISO8601 = function (date) {
    // return false if no data
    if (!date) {
      return false;
    }
    // return false if date not an object or not instance of Date
    if (typeof(date) !== 'object' || !(date instanceof Date)) {
      return false;
    }
    var year = date.getYear().toString(),
    month = XMLRPCMessage.leadingZero(date.getMonth().toString()),
    day = XMLRPCMessage.leadingZero(date.getDate().toString()),
    time = XMLRPCMessage.leadingZero(date.getHours().toString()),
    converted = '';
    time += ':' + XMLRPCMessage.leadingZero(date.getMinutes().toString());
    time += ':' + XMLRPCMessage.leadingZero(date.getSeconds().toString());
    converted = year + month + day + 'T' + time;
    return converted;
  };

  /**
  * Adds a leading '0' to one-char numbers
  * @method leadingZero
  * @memberof XMLRPCMessage
  * @param {number|string} n
  * @since 0.1.0
  */
  XMLRPCMessage.leadingZero = function (n) {
    if (!n) {
      return false;
    }
    if (typeof(n) !== 'number' &amp;&amp; typeof(n) !== 'string') {
      return false;
    }
    if (n.length === 1) {
      n = '0' + n;
    }
    return n;
  };

  /**
  * handles binary to ascii
  * @method btoa
  * @memberof XMLRPCMessage
  * @param {string} data
  * @since 0.1.0
  */
  XMLRPCMessage.btoa = function (data) {
    if (!data) {
      return false;
    }
    var ba = new Btoa();
    return ba.handle(data);
  };

  return XMLRPCMessage;
}));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Namespaces</h3><ul><li><a href="XMLRPCMessage.html">XMLRPCMessage</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Mon Feb 16 2015 02:51:46 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
