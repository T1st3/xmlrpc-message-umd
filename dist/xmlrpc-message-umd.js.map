{"version":3,"file":"xmlrpc-message-umd.js","names":[],"mappings":"","sources":["xmlrpc-message-umd.js"],"sourcesContent":["/*!\n* xmlrpc-message-umd\n*\n* @link https://github.com/T1st3/xmlrpc-message-umd\n* @author T1st3\n* @version 0.7.10\n* @license https://github.com/T1st3/xmlrpc-message-umd/blob/master/LICENSE\n*\n*\n* This AMD module is based on an XMLRPC message formatter written by Scott Andrew LePera\n*\n* Original work:\n* Copyright 2001 Scott Andrew LePera\n* scott@scottandrew.com\n* http://www.scottandrew.com/xml-rpc\n*\n* Original License:\n* You are granted the right to use and/or redistribute this\n* code only if this license and the copyright notice are included\n* and you accept that no warranty of any kind is made or implied\n* by the author.\n*\n*/\n\n/* global define */\n\n'use strict';\n\n(function (root, factory) {\n  // Test for AMD modules\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define([\n      'btoa'\n    ], factory);\n  // Test for Node.js\n  } else if (typeof exports === 'object') {\n    // Node\n    module.exports = factory(require('btoa-umd'));\n  // Browser globals\n  } else {\n    // Browser globals\n    root.XMLRPCMessage = factory(root.Btoa);\n  }\n}(this, function (Btoa) {\n  /**\n  * An XMLRPC message builder, AMD style\n  * @module XMLRPCMessage\n  * @namespace XMLRPCMessage\n  */\n\n  /**\n  * @constructor\n  * @since 0.1.0\n  */\n  var XMLRPCMessage = function (method) {\n    // set method if supplied\n    if (method) {\n      this.setMethod(method);\n    }\n    this.params = [];\n    return this;\n  };\n\n  /**\n  * set method\n  * @method setMethod\n  * @memberof XMLRPCMessage\n  * @param {string} methodName\n  * @since 0.1.0\n  */\n  XMLRPCMessage.prototype.setMethod = function (methodName) {\n    // Check methodName\n    if (!methodName) {\n      // keep chainability\n      return this;\n    }\n    this.method = methodName;\n    // keep chainability\n    return this;\n  };\n\n  /**\n  * add parameter\n  * @method addParameter\n  * @memberof XMLRPCMessage\n  * @param {*} data\n  * @since 0.1.0\n  */\n  XMLRPCMessage.prototype.addParameter = function (data) {\n    // Check data\n    if (arguments.length === 0) {\n      // keep chainability\n      return this;\n    }\n    this.params[this.params.length] = data;\n    // keep chainability\n    return this;\n  };\n\n  /**\n  * render xml message\n  * @method xml\n  * @memberof XMLRPCMessage\n  * @since 0.1.0\n  */\n  XMLRPCMessage.prototype.xml = function () {\n    var xml = '',\n    i = 0,\n    data = null;\n    xml += '<?xml version=\\'1.0\\'?>\\n';\n    xml += '<methodCall>\\n';\n    xml += '<methodName>' + this.method + '</methodName>\\n';\n    xml += '<params>\\n';\n    for (i = 0; i < this.params.length; i++) {\n      data = this.params[i];\n      xml += '<param>\\n';\n      xml += '<value>';\n      xml += XMLRPCMessage.getParamXML(data, XMLRPCMessage.dataTypeOf(data));\n      xml += '</value>\\n';\n      xml += '</param>\\n';\n    }\n    xml += '</params>\\n';\n    xml += '</methodCall>';\n\n    return xml;\n  };\n\n  /**\n  * get type of a var\n  * @method dataTypeOf\n  * @memberof XMLRPCMessage\n  * @param {*} o\n  * @param {string} forceType\n  * @since 0.1.0\n  */\n  XMLRPCMessage.dataTypeOf = function (o, forceType) {\n    if (forceType) {\n      return forceType;\n    }\n    // false if no o\n    if (!o && o !== false) {\n      return false;\n    }\n    var type = typeof(o),\n    con = null;\n    type = type.toLowerCase();\n    switch (type) {\n      case 'number':\n        if (Math.round(o) === o) {\n          type = 'int';\n        } else {\n          type = 'double';\n        }\n        break;\n      case 'object':\n        con = o.constructor;\n        if (con === Btoa) {\n          type = 'base64';\n        } else {\n          if (con === Date) {\n          type = 'date';\n          } else {\n            if (con === Array) {\n              type = 'array';\n            } else {\n              type = 'struct';\n            }\n          }\n        }\n        break;\n    }\n    return type;\n  };\n\n  /**\n  * XMLize a string or a number\n  * @method doValueXML\n  * @memberof XMLRPCMessage\n  * @param {*} data\n  * @param {string} type\n  * @since 0.1.0\n  */\n  XMLRPCMessage.doValueXML = function (data, type) {\n    // empty if no data\n    if (!data) {\n      return '';\n    }\n    var xml = '<' + type + '>' + data + '</' + type + '>';\n    return xml;\n  };\n\n  /**\n  * XMLize a boolean\n  * @method doBooleanXML\n  * @memberof XMLRPCMessage\n  * @param {boolean} data\n  * @since 0.1.0\n  */\n  XMLRPCMessage.doBooleanXML = function (data) {\n    // empty if no data\n    if (!data && data !== false) {\n      return '';\n    }\n    var value = (data === true) ? 1 : 0;\n    return '<boolean>' + value + '</boolean>';\n  };\n\n  /**\n  * XMLize a date\n  * @method doDateXML\n  * @memberof XMLRPCMessage\n  * @param {Object} data\n  * @since 0.1.0\n  */\n  XMLRPCMessage.doDateXML = function (data) {\n    // empty if no data\n    if (!data) {\n      return '';\n    }\n    var xml = '<dateTime.iso8601>';\n    xml += XMLRPCMessage.dateToISO8601(data);\n    xml += '</dateTime.iso8601>';\n    return xml;\n  };\n\n  /**\n  * XMLize base64 data\n  * @method doBase64XML\n  * @memberof XMLRPCMessage\n  * @param {Object} data\n  * @since 0.1.0\n  */\n  XMLRPCMessage.doBase64XML = function (data) {\n    // empty if no data\n    if (!data) {\n      return '';\n    }\n    var xml = '<base64>';\n    xml += data.a;\n    xml += '</base64>';\n    return xml;\n  };\n\n  /**\n  * XMLize an array\n  * @method doArrayXML\n  * @memberof XMLRPCMessage\n  * @param {Orray} data\n  * @since 0.1.0\n  */\n  XMLRPCMessage.doArrayXML = function (data) {\n    // empty if no data\n    if (!data) {\n      return '';\n    }\n    var xml = '<array><data>\\n',\n    i = 0;\n    for (i = 0; i < data.length; i++) {\n      xml += '<value>';\n      xml += XMLRPCMessage.getParamXML(data[i], XMLRPCMessage.dataTypeOf(data[i]));\n      xml += '</value>\\n';\n    }\n    xml += '</data></array>\\n';\n    return xml;\n  };\n\n  /**\n  * Create an XML 'struct' block\n  * @method doStructXML\n  * @memberof XMLRPCMessage\n  * @param {Object|Array} data\n  * @since 0.1.0\n  */\n  XMLRPCMessage.doStructXML = function (data) {\n    // empty if no data\n    if (!data) {\n      return '';\n    }\n    var xml = '<struct>\\n',\n    i = 0;\n    for (i in data) {\n      xml += '<member>\\n';\n      xml += '<name>' + i + '</name>\\n';\n      xml += '<value>' ;\n      xml += XMLRPCMessage.getParamXML(data[i], XMLRPCMessage.dataTypeOf(data[i]));\n      xml += '</value>\\n';\n      xml += '</member>\\n';\n    }\n    xml += '</struct>\\n';\n    return xml;\n  };\n\n  /**\n  * XMLize any var\n  * @method getParamXML\n  * @memberof XMLRPCMessage\n  * @param {*} data\n  * @param {string} type\n  * @since 0.1.0\n  */\n  XMLRPCMessage.getParamXML = function (data, type) {\n    if (!data && data !== false) {\n      return false;\n    }\n    if (!type) {\n      type = 'string';\n    }\n    var xml;\n    switch (type) {\n      case 'base64':\n        xml = XMLRPCMessage.doBase64XML(data);\n        break;\n      case 'date':\n        xml = XMLRPCMessage.doDateXML(data);\n        break;\n      case 'array':\n        xml = XMLRPCMessage.doArrayXML(data);\n        break;\n      case 'struct':\n        xml = XMLRPCMessage.doStructXML(data);\n        break;\n      case 'boolean':\n        xml = XMLRPCMessage.doBooleanXML(data);\n        break;\n      default:\n        xml = XMLRPCMessage.doValueXML(data, type);\n        break;\n    }\n    return xml;\n  };\n\n  /**\n  * Date to Iso8601\n  * @method dateToISO8601\n  * @memberof XMLRPCMessage\n  * @param {Object} date\n  * @since 0.1.0\n  */\n  XMLRPCMessage.dateToISO8601 = function (date) {\n    // return false if no data\n    if (!date) {\n      return false;\n    }\n    // return false if date not an object or not instance of Date\n    if (typeof(date) !== 'object' || !(date instanceof Date)) {\n      return false;\n    }\n    var year = date.getYear().toString(),\n    month = XMLRPCMessage.leadingZero(date.getMonth().toString()),\n    day = XMLRPCMessage.leadingZero(date.getDate().toString()),\n    time = XMLRPCMessage.leadingZero(date.getHours().toString()),\n    converted = '';\n    time += ':' + XMLRPCMessage.leadingZero(date.getMinutes().toString());\n    time += ':' + XMLRPCMessage.leadingZero(date.getSeconds().toString());\n    converted = year + month + day + 'T' + time;\n    return converted;\n  };\n\n  /**\n  * Adds a leading '0' to one-char numbers\n  * @method leadingZero\n  * @memberof XMLRPCMessage\n  * @param {number|string} n\n  * @since 0.1.0\n  */\n  XMLRPCMessage.leadingZero = function (n) {\n    if (!n) {\n      return false;\n    }\n    if (typeof(n) !== 'number' && typeof(n) !== 'string') {\n      return false;\n    }\n    if (n.length === 1) {\n      n = '0' + n;\n    }\n    return n;\n  };\n\n  /**\n  * handles binary to ascii\n  * @method btoa\n  * @memberof XMLRPCMessage\n  * @param {string} data\n  * @since 0.1.0\n  */\n  XMLRPCMessage.btoa = function (data) {\n    if (!data) {\n      return false;\n    }\n    var ba = new Btoa();\n    return ba.handle(data);\n  };\n\n  return XMLRPCMessage;\n}));\n"],"sourceRoot":"/source/"}